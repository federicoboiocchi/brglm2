% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solve_se.R
\name{solve_se}
\alias{solve_se}
\title{Solve the MDYPL state evolution equations with or without
intercept, with signal strength or contaminated signal strength}
\usage{
solve_se(
  kappa,
  ss,
  alpha,
  intercept = NULL,
  start,
  corrupted = FALSE,
  gh = NULL,
  prox_tol = 1e-10,
  transform = TRUE,
  init_method = "Nelder-Mead",
  init_iter = 50,
  ...
)
}
\arguments{
\item{kappa}{asymptotic ratio of columns/rows of the design
matrix. \code{kappa} should be in \verb{(0, 1)}.}

\item{ss}{signal strength or corrupted signal strength, depending
on whether \code{contaminated_ss = TRUE} or not. See Details.}

\item{alpha}{the shrinkage parameter of the MDYPL
estimator. \code{alpha} should be in \verb{(0, 1)}.}

\item{intercept}{if \code{NULL} (default) then the MDYPL state evolution
equations for the model with no intercept parameter are
solved. If a real then the equations for the models with
intercept parameter equal to \code{intercept} are solved. See
Details.}

\item{start}{a vector with starting values for \code{mu}, \code{b},\code{sigma}
(and \code{iota} if \code{intercept} is numeric).}

\item{corrupted}{if \code{FALSE} (default) then \code{ss} is signal strength
and \code{intercept}, if numeric, is the oracle intercept value. If
\code{TRUE}, then \code{ss} is the corrupted signal strength, and
\code{intercept}, if numeric, is the limit of the estimator computed
by \code{\link[=mdyplFit]{mdyplFit()}} with shrinkage parameter \code{alpha}. See Details.}

\item{gh}{A list with the Gauss-Hermite quadrature nodes and
nweights, as returned from \code{statmod::gauss.quad()} with \code{kind = "hermite"}. Default is \code{NULL}, in which case \code{gh} is set to
\code{statmod::gauss.quad(200, kind = "hermite")}.}

\item{prox_tol}{tolerance for the computation of the proximal
operator; default is \code{1e-10}.}

\item{transform}{if \code{TRUE} (default), the optimization is with
respect to \code{log(mu)}, \code{log(b)},\code{log(sigma)}, (and \code{iota} if
\code{intercept} is numeric). If \code{FALSE}, then it is over \code{mu}, \code{b},
\code{sigma} (and \code{iota} if \code{intercept} is numeric). The solution is
returned in terms of the latter set, regardless of how
optimization took place.}

\item{init_method}{The method to be passed to \code{\link[=optim]{optim()}}. Default is
\code{"Nelder-Mead"}.}

\item{init_iter}{how many iterations of \code{\link[=optim]{optim()}} should we make to
get starting values for \code{\link[nleqslv:nleqslv]{nleqslv::nleqslv()}}? Default is \code{50},
but can also be \code{0} in which case \code{start} is directly passed to
\code{nleqslv:nleqslv()}. \code{init_iter = "only"} results in only
\code{\link[=optim]{optim()}} being used. See Details.}

\item{...}{further arguments to be passed to \code{\link[nleqslv:nleqslv]{nleqslv::nleqslv()}},
unless \code{init_iter = "only"}, in which case \code{...} is further
arguments to be passed to \code{\link[=optim]{optim()}}.}

\item{mu}{aggregate bias parameter.}
}
\description{
Solve the MDYPL state evolution equations with or without
intercept, with signal strength or contaminated signal strength
}
\details{
\code{init_iter} iterations of \code{\link[=optim]{optim()}} with \code{method = init_method} are
used towards minimizing \code{sum(se)^2}, where se is a vector of the
state evolution functions. The solution is then passed to
\code{nleqslv::nleqslv()} for a more aggressive iteration.

If \code{corrupted = FALSE} (default), then \code{ss} is the square root of
the signal strength, which is the limit \deqn{\gamma^2} of
\eqn{var(X \beta)}. If \code{corrupted = TRUE}, then \code{ss} is the square
root of the corrupteed signal strength which is the limit
\deqn{\nu^2} of \eqn{var(X \hat\beta(\alpha))}, where
\eqn{\hat\beta(\alpha)} is the maximimum Diaconis-Ylvisaker prior
penalized likelihood (MDYPL) estimator as computed by \code{\link[=mdyplFit]{mdyplFit()}}
with shirnkage parameter \eqn{alpha}.

If \code{intercept = NULL}, then the state evolution equations are
solved for the model without intercept. If \code{intercept} is a real
number, then the state evolution equations for the model with
intercept are solved (i.e. with predictor \deqn{\eta_i = \theta +
x_i^T \beta}). In that case, what \code{intercept} represents depends on
the value of \code{corrupted}. If \code{corrupted = FALSE}, \code{intercept}
represents the oracle value of $\theta$, otherwise it represents
the limit of the MDYPL estimator of $\theta$ as computed by
\code{\link[=mdyplFit]{mdyplFit()}} shrinkage parameter \code{alpha}.
}
